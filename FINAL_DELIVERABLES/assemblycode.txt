ADDI R2,R0,2	//POINTS TO SKEY[0]
ADDI R3,R0,1	//COUNTER
ADDI R4,R0,26
OR R7,R0,R30	//R7 = S[i-1]
SW R7, (R2)
ADDI R2,R2,1
ADDI R8,R0,0	//R8 = S[i]
ADD R8,R7,R29	//R8 = S[i-1] + Q
SW	R8,(R2)		//STORE S[i] TO MEM
ADDI R2,R2,1	//MOVE EMPTY MEM POINTER 1 DOWN
ADDI R7,R8,0	//RENEW R7(S[i-1])
ADDI R3,R3,1
BLT R4,R3,-6
ADDI R21,R0,0	//COUNTER FOR i
ADDI R22,R0,0	//COUNTER FOR j
ADDI R3,R0,0	//COUNTER FOR k
ADDI R24,R0,26
ADDI R23,R0,4	//c=4
ADDI R4,R0,78
ADDI R9,R0,53	//POINTS TO L[0]
ADDI R10,R0,2	//POINTS TO S[0]
ADDI R11,R0,0	//RGT FOR L[]
ADDI R12,R0,0	//RGT FOR S[]
ADDI R25,R0,0	//A
ADDI R26,R0,0	//B
LW	R12,(R10)	//R12 LOAD S[i] 
LW  R11,(R9)	//R11 LOAD L[J]
ADD R15,R25,R26	//A + B
ADD	R12,R15,R12	//S[i] + A + B
SHL R13,R12,3	//SHIFT LEFT 3
SHR	R14,R12,29	//SHIFT RIGHT 29
OR R12,R13,R14	//GET ROTATED S[i]
ADD R25,R0,R12	//A = S[i]
SW R12,(R10)
ADD R15, R25,R26	//A+B
ADD R11,R15,R11	//L[j] + A + B
ADDI R16,R0,31
ADDI R17,R0,32
AND R15, R15, R16
SUB R18,R15,R17	//OVERFLOW BITS
ADDI R19,R0,0	//COUNTER
ADDI R20,R11,0	//COPY R11
BEQ R19,R15,3
SHL R11,R11,1
ADDI R19,R19,1
BLT R15,R19,-3
ADDI R19,R0,0
BEQ R19,R18,3
SHR R20,R20,1
ADDI R19,R19,1
BLT R18,R19,-3
OR R11,R11,R20
ADD	R26,R0,R11	//B = L[j]
SW R11,(R9)
ADDI R21,R21,1	//i++
ADDI R10,R10,1	//POINTER FOR S[i] 1 DOWN
BNE R21, R24,2	//IF i == 26, i=0; POINTER FOR S[I] RETURN TO S[0]
ADDI R21,R0,0
ADDI R10,R0,2	
ADDI R22,R22,1	//j++
ADDI R9,R9,-1
BNE R22, R23,2	//IF j==4,j=0; POINTER FOR L[j] RETURN TO J[0]
ADDI R22,R0,0
ADDI R9, R0, 53
ADDI R3,R3,1	//K++
BNE R3,R4,-41
ADDI R0,R0,0
ADDI R28,R0,40
SW R29,(R28)


ADDI R1,R0,0
LW R2, (R1)	//R2 = PT[0]
ADDI R1,R1,1	//R1 + 1
LW R3,(R1)	//R3 = PT[1]
ADDI R1,R1, 1	//R1+1
LW R4,(R1)	//R4 LOAD S[0]
ADD R2,R2,R4 //A
ADDI R1,R1,1
LW R4,(R1) //LOAD S[1]
ADD R3,R3,R4	//B
ADDI R5,R0,1	//i = 1
ADDI R6,R0,13	//r = 13
NOR R8,R2,R0	//NOT A
NOR R9,R3,R0	//NOT B
AND	R10,R8,R3	//NOT A AND B
AND R11,R9,R2	//NOT B AND A
OR	R10,R11,R10	//XOR A AND B
ADDI R17,R0,31	//R17 = 31
ADDI R15,R0,32	//R15 = 32
ADDI R16,R3,0	//COPY B(R3) TO R16
AND R16,R16,R17
SUB R18,R16,R15 //GET OVERFLOW BITS
ADDI R12,R0,0	//R12 IS COUNTER OF ROTATION
ADDI R19,R10,0  // COPY CURRENT A(R10)
BEQ R12,R16,3	//IF R12 == BLT
SHL R10,R10,1	//SHIFT LEFT BY 1
ADDI R12,R12,1	//R12 += 1
BLT R16,R12,-3	//JUMP
ADDI R12,R0,0	//R12 IS COUNTER OF ROTATION
BEQ R12,R18,3	//IF R12 == BLT
SHR R19,R19,1	//SHIFT RIGHT BY 1
ADDI R12,R12,1	//R12 += 1
BLT R18,R12,-3	//JUMP
OR R10,R10,R19 //CONSTRUCT ROTATED A(R10)
ADDI R1,R1,1
LW R4,(R1)
ADD R2,R10,R4	//FINAL A
NOR R8,R2,R0
AND R10,R8,R3
AND R11,R9,R2
OR R10,R11,R10
ADDI R17,R0,31	//R17 = 31
ADDI R15,R0,32	//R15 = 32
ADDI R16,R2,0	//COPY A(R3) TO R16
AND R16,R16,R17
SUB R18,R16,R15 //GET OVERFLOW BITS
ADDI R12,R0,0	//R12 IS COUNTER OF ROTATION
ADDI R19,R10,0  // COPY CURRENT B(R10)
BEQ R12,R16,3	//IF R12 == BLT
SHL R10,R10,1	//SHIFT LEFT BY 1
ADDI R12,R12,1	//R12 += 1
BLT R16,R12,-3	//JUMP
ADDI R12,R0,0	//R12 IS COUNTER OF ROTATION
BEQ R12,R18,3	//IF R12 == BLT
SHR R19,R19,1	//SHIFT RIGHT BY 1
ADDI R12,R12,1	//R12 += 1
BLT R18,R12,-3	//JUMP
OR R10,R10,R19 //CONSTRUCT ROTATED B(R10)
ADDI R1,R1,1
LW R4,(R1)
ADD R3,R10,R4
ADDI R5,R5,1
BLT R6,R5,-51
ADDI R14,R0,28
SW R2,(R14)
ADDI R14,R0,29
SW R3,(R14)
ADDI R28,R0,40
SW R30,(R28)


ADDI R1,R0,0
LW R2, (R1)	// A, R2 = CT[0]
ADDI R1,R1,1	//R1 + 1
LW R3,(R1)	// B, R3 = CT[1]
ADDI R5,R0,1	//i = 1
ADDI R6,R0,13	//r = 13
ADDI R1,R0,27	//R1 - 4
LW R4,(R1)		//R4 = S[25]
SUB R3,R4,R3
ADDI R17,R0,31	//R17 = 31
ADDI R15,R0,32	//R15 = 32
ADDI R16,R2,0	//COPY A(R2) TO R16
AND R16,R16,R17
SUB R18,R16,R15 //GET OVERFLOW BITS
ADDI R12,R0,0	//R12 IS COUNTER OF ROTATION
ADDI R19,R3,0  // COPY CURRENT B(R10)
BEQ R12,R16,3	//IF R12 == BLT
SHR R3,R3,1	//SHIFT LEFT BY 1
ADDI R12,R12,1	//R12 += 1
BLT R16,R12,-3	//JUMP
ADDI R12,R0,0	//R12 IS COUNTER OF ROTATION
BEQ R12,R18,3	//IF R12 == BLT
SHL R19,R19,1	//SHIFT RIGHT BY 1
ADDI R12,R12,1	//R12 += 1
BLT R18,R12,-3	//JUMP
OR R3,R3,R19 //CONSTRUCT ROTATED B(R10)
NOR R8,R3,R0	//R8 NOT R3
NOR R9,R2,R0	//R9 NOT A
AND R10, R3,R9
AND R11,R2,R8
OR	R3, R11, R10	//XOR A AND B
ADDI R1,R1,-1
LW R4,(R1)
SUB R2,R4,R2
ADDI R17,R0,31	//R17 = 31
ADDI R15,R0,32	//R15 = 32
ADDI R16,R3,0	//COPY B(R3) TO R16
AND R16,R16,R17
SUB R18,R16,R15 //GET OVERFLOW BITS
ADDI R12,R0,0	//R12 IS COUNTER OF ROTATION
ADDI R19,R2,0  // COPY CURRENT A(R2)
BEQ R12,R16,3	//IF R12 == BLT
SHR R2,R2,1	//SHIFT RIGHT BY 1
ADDI R12,R12,1	//R12 += 1
BLT R16,R12,-3	//JUMP
ADDI R12,R0,0	//R12 IS COUNTER OF ROTATION
BEQ R12,R18,3	//IF R12 == BLT
SHL R19,R19,1	//SHIFT LEFT BY 1
ADDI R12,R12,1	//R12 += 1
BLT R18,R12,-3	//JUMP
OR R2,R2,R19 //CONSTRUCT ROTATED A(R2)
NOR R8,R2,R0	//R8 NOT R2
NOR R9,R3,R0	//R9 NOT B
AND R10, R2,R9
AND R11,R8,R3
OR R2, R11, R10	//XOR A AND B
ADDI R5,R5,1
ADDI R1,R1,-1
BLT R6,R5,-52
ADDI R0,R0,0
LW R4,(R1)	//R4 LOAD S[1]
SUB R3,R4,R3 //FINAL B
ADDI R1,R1,-1
LW R4,(R1) //LOAD S[0]
SUB R2,R4,R2	//FINAL A
ADDI R14,R0,32
SW R2,(R14)
ADDI R14,R0,33
SW R3,(R14)
ADDI R28,R0,40
SW R31,(R28)
BEQ R0,R0,-1